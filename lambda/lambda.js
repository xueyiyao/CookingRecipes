const AWS = require("aws-sdk");
const ddb = new AWS.DynamoDB.DocumentClient({ region: "us-west-2" });

exports.handler = async (event, context, callback) => {
  const { itemID, buyerID, sellerID } = event;

  // If arguments are not provided, then send "bad request" response back
  if (!(itemID && buyerID && sellerID)) {
    callback(null, {
      statusCode: 400,
      body: "Bad Request",
      headers: {
        "Access-Control-Allow-Origin": "*",
      },
    });
    return;
  }

  const recipeParams = {
    TableName: "Recipe",
    Key: { id: itemID },
  };

  const buyerParams = {
    TableName: "User",
    Key: { id: buyerID },
  };

  const sellerParams = {
    TableName: "User",
    Key: { id: sellerID },
  };

  try {
    // first get recipe and user information
    const recipeData = await ddb.get(recipeParams);
    const buyerData = await ddb.get(buyerParams);
    const sellerData = await ddb.get(sellerParams);

    // check if user has enough coins
    if (!recipeData) throw new Error("No Recipe");
    if (recipeData.price && recipeData.price > buyerData.cookingCoin)
      throw new Error("Buyer Doesn't Have Enough Coins");

    const orderId = "some-generated-id";

    // create the order
    const orderResponse = await createOrder(
      itemID,
      buyerID,
      sellerID,
      orderId,
      recipeData
    );

    // update the buyer
    const buyerResponse = await updateBuyer(
      itemID,
      buyerID,
      sellerID,
      orderId,
      recipeData,
      buyerData
    );

    // update the seller
    const sellerResponse = await updateSeller(
      itemID,
      buyerID,
      sellerID,
      orderId,
      recipeData,
      sellerData
    );

    // update the recipe
    const recipeResponse = await updateRecipe(itemID, buyerID);

    // return response
    callback(null, {
      statusCode: 201,
      body: "",
      headers: {
        "Access-Control-Allow-Origin": "*",
      },
    });
  } catch (error) {
    console.log(error);
  }
};

const createOrder = (itemId, buyerId, sellerId, orderId, recipeData) => {
  const params = {
    TableName: "Order",
    Item: {
      id: "some-generated-id",
      item: itemId,
      // date: autogenerated?
      price: recipeData.price,
      seller: sellerId,
      buyer: buyerId,
    },
  };

  return ddb.put(params).promise();
};

const updateBuyer = (
  itemId,
  buyerId,
  sellerId,
  orderId,
  recipeData,
  buyerData
) => {
  const params = {
    TableName: "User",
    Key: { id: buyerId },
    UpdateExpression:
      "set purchasedRecipes = list_append(purchaseRecipes, :r), buyTransactions = list_append(buyTransaction, :o), cookingCoin :c",
    ExpressionAttributeValues: {
      ":r": itemId,
      ":o": orderId,
      ":c": buyerData.cookingCoin - recipeData.price,
    },
  };

  return ddb.update(params).promise();
};

const updateSeller = (
  itemId,
  buyerId,
  sellerId,
  orderId,
  recipeData,
  sellerData
) => {
  const params = {
    TableName: "User",
    Key: { id: sellerId },
    UpdateExpression:
      "set sellTransactions = list_append(sellTransaction, :o), cookingCoin :c",
    ExpressionAttributeValues: {
      ":o": orderId,
      ":c": sellerData.cookingCoin + recipeData.price,
    },
  };

  return ddb.update(params).promise();
};

const updateRecipe = (itemId, buyerId) => {
  const params = {
    TableName: "Recipe",
    Key: { id: itemId },
    UpdateExpression: "set purchasers = list_append(purchasers, :p)",
    ExpressionAttributeValues: {
      ":p": buyerId,
    },
  };

  return ddb.update(params).promise();
};
